# 프로세스와 스레드

## 개념

### 프로그램

프로그램이란 디스크 내의 실행 가능한 파일로 현재 실행중인 프로그램을 태스크 (task)라고 부른다. 예를 들어, 윈도우 환경에서 엑셀 프로그램을 띄우면 이는 프로세스가 된다.

### 프로세스

프로세스는 프로그램이 실행중인 상태로 특정 메모리 공간에 프로그램의 코드가 적재되고 CPU가 해당 명령어를 하나씩 수행하고 있는 상태를 의미한다.

운영 체제에서는 프로세스를 사용하여 **프로그램을 수행**한다.

### 스레드

스레드는 운영체제에서 **프로세서 시간을 할당하는 기본 단위**로 하나 이상의 쓰레드가 해당 프로세스 내에서 코드를 실행한다.

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20dc1c2/Untitled.png)

---

## 프로세스의 특징

1. 하나의 프로그램이 여러 프로세스 생성 가능
2. 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있음
3. 각각 독립된 메모리 영역을 할당받음(Code, Data, Stack, Heap 구조 등)
4. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근 불가 → 한 프로세스가 다른 프로세스의 자원에 접근하기 위해서는 프로세스간의 통신 (IPC)을 사용하여 접근해야 한다
    
    <aside>
    📌 **IPC (프로세스 통신)**
    프로세스끼리 정보나 데이터를 서로 주고받는 방법
    커널에서 IPC를 위한 도구를 제공하며,  시스템 콜의 형태로 제공됨
    
    **통신 방법**
    
    - Pipe : 한 쪽 방향으로 통신하는 반 이중 통신
    - Message Queue : 다른 프로세스와 단 방향 통신하지만, 여러개의 프로세스가 동시에 데이터를 다룰 수 있음
    - Shared Memory : 프로세스간의 메모리 영역을 양방향으로 공유하는 공간
    - Socket : 컴퓨터끼리의 통신을 도와주기 위한 통신 계층 (양방향 )
    </aside>
    

### 프로세스 구성 요소

![프로세스 내부 구조](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20dc1c2/Untitled%201.png)

프로세스 내부 구조

프로세스의 구조체에는 프로세스마다 독립적으로 관리해야 하는 유저 메모리 영역이나, 프로세스가 사용하는 각종 객체들의 포인터를 관리하는 핸들 테이블을 가지고 있다.

1. 유저 메모리 영역 관리(Virtual Address Descriptors)
프로세스별로 독립된 영역을 가지게 되는 곳은 유저 메모리 공간이다. 커널 메모리 공간의 경우 모든 프로세스가 공유하여 사용하고 있다.
VAD(Virtual Address Descriptors)에는 프로세스에서 버추얼 메모리 할당 함수로 할당한 메모리나 파일을 매핑함으로써 생성된 메모리 등과 같은 유저 메모리의 할당 정보를 바이너리 트리 형태로 가지고 있다.
2. 핸들 테이블 (Handle Tables)
핸들 테이블은 모든 프로세스에서 사용하는 모든 핸들들에 대한 커널 객체 포인터 정보를 배열 형태로 가지고 있는 공간이다. 
프로세스가 종료될 때 이 테이블의 정보를 참고하여 이 프로세스에서 사용하고 있는 모든 커널 객체를 자동으로 반환한다.
3. 독립적인 메모리 공간
프로세스 단위로 관리되는 자원 중 가장 중요한 구별점은 가상 메모리다. [페이징 기법](https://coder-in-war.tistory.com/entry/OS-15-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5-%EB%8B%A8%EC%88%9C-Paging)을 이용하여 프로세스마다 별도의 고유한 메모리를 사용할 수 있게 하고 있다.

### 프로세스의 메모리 구조

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20dc1c2/Untitled%202.png)

1. Code: 프로그램 명령이 위치하는 곳으로 기계어로 제어되는 영역
2. Data: 전역 변수나 static변수의 할당을 위해 존재하는 공간
3. 지역 변수 할당과 함수 호출 시 전달되는 인자값들을 저장하기 위한 공간
4. Heap : C의 malloc, callod와 C++, Java의 new를 통한 동적 할당을 위해 존재하는 공간

### 프로세스 제어 블록 (PCB)

프로세스가 실행될 때 마다 프로세스의 정보를 기록해 두는 특별한 자료구조

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20dc1c2/Untitled%203.png)

1. 프로세스를 구분하는 ID
2. 각 State들의 상태를 저장
3. 우선순위, 최종 실행 시간, CPU 점유 시간 등이 포함
4. 다음 명령어 주소를 저장하는 카운터
5. 각종 레지스터 값
6. 프로세스 주소 공간 정보를 저장
7. 프로세스를 위해 열려있는 파일 목록
8. 부모/자식 프로세스에 관한 포인터
9. 프로세스에 할당한 입출력 장치 목록
10. 스케줄링 큐 포인터, 소유자 등

운영체제가 현제 CPU 제어권을 다른 프로세스에게 넘겨줄 떄, 실행중인 프로세스의 정보를 PCB에 저장해놓고 다시 CPU 제어권을 넘겨받은 경우 PCB에 저장되어있던 정보들을 불러와서 추후 작업을 실행한다.

### 프로세스 상태

1. 생성 (NEW) : 프로세스가 생성중
프로세스가 생성되었지만 프로그램이 메모리에 아직 적재되지 않은 상태
2. 준비 (READY) : 프로세스가 설정되어 대기중
CPU를 할당받기 위해 준비중인 상태 (QUEUE에서 대기하고 있는 상태. 물리적인 메모리에 적재된 상태)
3. 실행 (RUNNING) : 프로세스가 실행되는 중
프로세스가 CPU를 할당받아 기계어 명령을 수행중인 상태
4. 대기 (BLOCK, WAIT, SLEEP) : 프로세스가 어떤 사건이 발생하기를 기다리는 상태
프로세스에 입출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입출력 처리가 완료될 때 까지 대기하는 상태
5. 종료 (EXIT) : 프로세스 실행 종료
프로그램이 메모리에서 해제되어 정리하는 작업을 진행

### 프로세스 상태 전이

1. 디스패치 : 준비 → 실행
2. 타임 아웃 : 실행 → 준비
3. 대기(Block) 또는 사건 준비 (Event Wait) : 실행 → 대기
4. 깨움(Wake Up) 또는 사건 발생(Event Occurs) : 대기 → 준비

![Untitled](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20dc1c2/Untitled%204.png)

생성 → 준비 : 프로세스가 생성되면 OS 커널에 존재하는 Ready Queue에 올라감

준비 → 실행 : Ready Queue에 있는 프로세스들을 OS 프로세스 스케쥴링에 의해 CPU 할당

실행 → 준비 : 현재 실행중인 프로세스보다 Ready Queue에서 대기중인 프로세스의 우선순위가 높으면 현재 프로세스는 준비상태로 오게 되고 우선순위가 더 높은 프로세스가 준비 상태가 되어 CPU를 할당받음

실행 → 대기 : 현재 실행중인 프로세스에 입출력 이벤트 발생 → 현재 프로세스는 blocked 상태가 됨

실행 → 종료 : 프로세스 종료

### Context Switch (문맥 교환)

문맥 교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어건이 넘어가는 과정이다. 

실행 상태에 있던 프로세스(A)가 입출력을 요청해야하는 경우가 생겼을 때, 입출력을 하기 위해서 프로세스는 I/O를 요청하는  시스템 콜을 발생시키고, 프로세스는 device queue에 줄을 서서 준비 상태로 상태가 변경된다. 그리고 준비 큐에 있던 다른 프로세스 (B)가 CPU를 할당 받아 명령을 수행하게 되는걸 문맥 교환이라고 한다.

---

## 스레드의 특징

1. 스레드는 메모리를 서로 공유할 수 있다 → 스레드는 프로세스 내에서 각각 stack 만 할당 받고 Code, Data, Heap 영역은 공유한다
2. 한 스레드가 프로세스 자원을 변경하면, 다른 아웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다

### 자바 스레드

- 자바 스레드는 일반 스레드와 차이가 거의 없으며, JVM이 운영체제의 역할을 한다
- 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM 에 의해 스케줄 되는 실행 단위의 코드 블록임
- 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어지고 JVM은 스레드가 몇개 존재하는지, 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지, 스레드의 상태와 우선순위 등을 관리한다.

---

## 멀티 프로세스 vs 멀티 스레드

### 멀티 프로세스

두개 이상 다수의 프로세서(CPU)가 협력적으로 하나 이상의 작업(task)을 동시에 처리하는 것(병렬 처리)로, 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용한다.

장점

- 독립된 구조로 안정성이 높음
- 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않음 → 정지되거나 하는 문제 발생 x
- 여러개의 프로세스가 처리되어야 할 때, 동일한 데이터를 사용하고 이런 데이터를 하나에 디스크에 두고 모든 프로세서(CPU)가 이를 공유하면 비용적으로 저렴함

문제점

- 독립된 메모리 영역이기 때문에 작업량이 많을 수록 오버 헤드가 발생하여 성능 저하가 발생 할 수 있다
*오버헤드: 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 및 메모리 등
- Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모되는 등 오버헤드가 발생

### 멀티 스레드

 하나의 응용 프로그램을 여러개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다. 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.

![Heee's Development Blog](%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20dc1c2/Untitled%205.png)

Heee's Development Blog

장점

- 시스템 자원 소모 감소 (자원의 효율성 증대): 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 자원을 효율적으로 관리할 수 있음
- 시스템 처리율 향상 (처리비용 감소) : 스레드 간 데이터를 주고 받는것이 간단해지고 시스템 자원 소모가 줄어듦 → 스레드 사이 작업량이 작아 context switching이 빠르고 캐시 메모리를 비울 필요가 없음
- 스레드는 스택 영역을 제외한 메모리 영역을 공유하여 통신 비용이 적음

문제점

- 자원을 공유하기 때문에 **동기화 문제**가 발생할 수 있음(병목 현상, 데드락 등)
- 주의깊은 설계가 필요하고 디버깅이 어려움 → 불필요한 부분까지 동기화 하면 대기시간으로 인해 성능 저하가 발생함
- 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받음
- 단일 프로세스 시스템의 경우 효과 기대 x