# 소프트웨어 개발 프로세스

### 좁은 의미에서 소프트웨어 개발 프로세스란 소프트웨어 제품을 개발할 때 필요한 절차, 과정, 그리고 구조를 일컫는 말로, 사용자의 요구 사항을 소프트웨어 시스템으로 구현하기 위한 일련의 활동이라고 볼 수 있다.

### 넓은 의미에서는 절차나 구조뿐만 아니라 그 작업을 수행하는 데 필요한 방법과 도구를 비롯해 개발과 관련된 실제 절차를 따라 작업을 수행하는 참여자들까지도 포함된다. 즉 소프트웨어 개발 목적을 이루는 데 필요한 통합적 수단이라 할 수 있다.

<br>

---

<br>

## 1. 주먹구구식 모델

### - 즉흥적 소프트웨어 개발 또는 코딩과 수정 모델이라고도 한다.

### - 공식적인 가이드라인이나 프로세스가 없는 개발 방식이다.

### - 일단 코드를 작성하여 제품을 만들어본 후에 요구 분석, 설계, 유지보수에 대해 생각하는 것으로 다음의 단계로 이루어진다.

![image](https://user-images.githubusercontent.com/71022555/144890181-aca06296-9f05-47f0-8110-1ee7cbc4ac3b.png)
<br>

## 특징

### ◆ 개발자 한 명이 단시간에 마칠 수 있는 경우에나 사용할 수 있는 방법이다.

### ◆ 실제 개발현장에서 사용하기에는 문제가 많다.

### ◆ 각 단계별로 산출물이 없어 관리 및 유지보수가 매우 어렵다.

<br>

---

## 2. ★ 폭포수 모델(선형 순차적 모델)

### - 소프트웨어 공학의 대명사로 여겨질 만큼 소프트웨어 프로세스의 초기에 개발된 전통적인 모델이다.

### - 폭포의 물이 위에서 아래로 떨어지듯이 계획, 분석, 설계, 구현, 테스트, 유지보수의 각 단계가 하향식으로 진행되며, 병행되거나 거슬러 반복되지 않는다. 각 단계가 끝날 때마다 확실히 매듭을 짓고 그 결과를 확인한 후에 다음 단계로 진행한다.

![image](https://user-images.githubusercontent.com/71022555/144890763-deabf1a6-726a-4a78-911a-eb8adc2ed53e.png)
<br>

## 폭포수 모델 개발 각 단계에서 하는 일

### 1. 계획단계

- ### 문제를 정의한 후 프로젝트 영역을 결정한다.
- ### 작업 분할 구조도(WBS: Work Breakdown Structure)를 이용하여 세부 작업을 결정한다.
- ### CPM을 이용해 작업 순서를 결정한다.
- ### 간트 차트를 이용해 일정표를 작성한다.
- ### 기능 점수등을 이용해 프로젝트에 소요되는 비용을 산정한다.
- ### 계획 단계의 최종 산출물인 '개발 계획서'를 작성한다.
  [개발 계획서](https://www.google.com/search?q=%EA%B0%9C%EB%B0%9C+%EA%B3%84%ED%9A%8D%EC%84%9C&sxsrf=AOaemvJQp5DK2rAO5LDi7Id2b0kfhvLxlQ:1638811047581&source=lnms&tbm=isch&sa=X&ved=2ahUKEwip9eDy1s_0AhUHZt4KHcnJDp0Q_AUoAXoECAEQAw&biw=958&bih=927&dpr=1)
  <br>

### 2. 요구 분석단계

- ### 기존 시스템을 분석하고, 인터뷰 등을 통해 사용자의 요구 사항을 수집한다.
- ### 사용자가 요구하는 기능적 요구 사항과 비기능적 요구 사항을 파악한다.
- ### 각 방법론에 따른 표기법을 이용해 정리된 요구 사항을 표현한다.
- ### 객체지향 방법론에서는 유스케이스 다이어그램을 작성한다.
- ### 요구 분석 단계의 최종 산출물인 '요구 분석 명세서'를 작성한다.
  [요구 분석 명세서](https://www.google.com/search?q=%EC%9A%94%EA%B5%AC%EB%B6%84%EC%84%9D+%EB%AA%85%EC%84%B8%EC%84%9C&tbm=isch&ved=2ahUKEwi4j8P11s_0AhUIZ94KHYDLCPUQ2-cCegQIABAA&oq=%EC%9A%94%EA%B5%AC&gs_lcp=CgNpbWcQARgAMgcIIxDvAxAnMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDIFCAAQgAQyBQgAEIAEMgUIABCABDIFCAAQgAQyBQgAEIAEOggIABCABBCxAzoECAAQA1DSAViJB2D1DmgBcAB4AYABgwGIAfUEkgEDMC41mAEAoAEBqgELZ3dzLXdpei1pbWfAAQE&sclient=img&ei=rUWuYfiEF4jO-QaAl6OoDw&bih=927&biw=958)
  <br>

### 3. 설계단계

- ### 설계 단계는 크게 전체적인 시스템 구성을 나타내는 상위 설계(아키텍쳐 설계)와 각 모듈(컴포넌트, 자료구조, 알고리즘)의 세부 내용을 설계하는 하위 설계로 나뉜다.
  | 종류      | 설명                                                                                                                                                                                |
  | --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
  | 상위 설계 | ● 개발하려는 소프트웨어의 전체구조를 볼 수 있는 아키텍처를 설계한다.<br> ● 아키텍처의 품질 속성을 결정한다.<br> ● 아키텍처의 스타일을 결정한다. <br>●설계 패턴을 결정한다.          |
  | 하위 설계 | ● 모듈 간의 결합도와 모듈 내의 응집력을 고려해 각 모듈의 세부 내용을 설계한다.<br> ● 객체지향 방법론에 따라 설계를 한다면 설계 원리, 클래스 간의 관계, 클래스 설계 원칙을 고려한다. |
  <br>

### 4. 구현단계

- ### 코딩을 하는 단계로 가능한 표준 코딩 스타일을 지키며 보안을 고려하여 시큐어 코딩 방법도 고려하여 보안에 취약하지 않도록 코딩한다.
<br>

### 5. 테스트단계

테스트 방법은 다음과 같이 다양한 방법으로 분류할 수 있으므로 프로젝트의 성격에 맞는 방법을 선택한다.

- ### 개발자 또는 사용자 시각에 따른 분류
- ### 사용되는 목적에 따른 분류
- ### 프로그램의 실행 요구 여부에 따른 분류
- ### 품질 특성에 따른 분류
- ### 소프트웨어 개발 단계에 따른 분류
<br>

### 6. 유지보수단계

추가 요구 사항, 수정 사항 등이 발생했을 때 소프트웨어를 유지보수하는 단계이다.

- ### 수정 유지보수
- ### 적응 유지보수
- ### 기능 보강 유지보수
- ### 예방 유지보수

![image](https://user-images.githubusercontent.com/71022555/144891271-7d1db27c-1ac9-4bbc-9878-e2f2f54cb3f3.png)
<br>

## □ 장점

- ### 관리가 용이하다.
  - ### 순차적 모델이므로 단계별 진척 사항에 대한 관리가 용이하다.
  - ### 유사한 분야의 개발 경험이 많으면 효율과 품질 측면에서 우수한 결과를 가져올 수있다.
- ### 체계적으로 문서화할 수 있다.
  - ### 각 단계별 산출물을 체계적으로 문서화하여 산출물을 검토하여 프로젝트의 진행을 명확하게 할 수 있다.
- ### 요구 사항의 변화가 적은 프로젝트에 적합하다.
  - ### 폭포수 모델은 초기에 어느 정도 요구 사항의 확정되고 요구 사항의 변화가 비교적 적은 형태의 프로젝트를 개발할 때 적합하다.

## ■ 단점

- ### 앞 단계가 완료되어야 수행할 수 있다.
  - ### 앞 단계가 완료될 때 까지 대기해야 하며 각 단계 개발하는 도중 사용자의 요구 사항을 반영할 수 있는 체계적인 방법이 없다.
- ### 각 단계마다 결과물의 완벽한 수준으로 작성되어야 다음 단계에 오류를 넘겨주지 않는다.
- ### 사용자가 중간에 가시적인 결과를 볼 수 없다.
<br>

---

## 3. V 모델

<img src="https://user-images.githubusercontent.com/71022555/144893629-47cd7414-e384-4ed1-b8bd-1eb1a1c03ffa.png" width="700" height="350"/>

### - 폭포수 모델의 확장형태

### - 생명주기 단계별로 상응하는 테스트 단계가 존재

### - V 형태로 진행(아래 방향으로 진행하다가 코딩 단계를 거치면서 위로 향함)

### - 폭포수 모델에 비해 반복과 재처리 과정이 명확하다.

<br>

---

## 4. 프로토타입 모델

### - 완전한 소프트웨어를 만들기 전에 사용자의 요구를 받아 일단 모형을 만들고 이 모형을 사용자와 의사소통하는 도구로 활용한다(ex 아파트 모델하우스)

### - 프로토타입을 만다는 것을 프로토타아핑이라 한다.

### - 개발자는 초기 요구 사항을 바탕으로 1차 프로토타입을 만들고 이를 기반으로 개선하여 2차 프로토타입을 만든다. 이 과정을 사용자가 만족할 때까지 반복한다.

### - 사용자의 요구가 불투명하고 요구 사항의 변화가 계속 많이 발생하는 경우에 적합하다.

### ◐ 실험적 프로토타입 모델

- ### 프로토타입을 완성하고 사용자의 요구를 가지고 다시 처음부터 본격적으로 제품을 만든다.
- ### 최종 프로토타입은 최종적으로 사용하지 않는다. ( ex) 모델하우스와 유사한 개념)
  ![image](https://user-images.githubusercontent.com/71022555/144895225-b776a4d6-5926-424f-a021-cd9bfc189b1a.png)
  <br>

### ◑ 진화적 프로토타입 모델

- ### 사용자의 요구를 충분히 반영하여 구현된 프로토타입을 버리지 않고 지속적으로 개선, 보완하여 최종 시스템으로 완성시킨다.(ex) 나선형 모델)
  ![image](https://user-images.githubusercontent.com/71022555/144894933-7d59dbb6-e5b0-4805-8131-b4a75d226215.png)

## □ 장점

- ### 가시적인 결과를 개발자와 사용자와의 의사소통 도구로 활용할 수 있다.
- ### 프로토타입 사용을 통해 예상치 못한 새로운 요구 사항들을 발견할 수 있으며 개발되는 소프트웨어를 에측할 수 있다.
- ### 이미 개발 과정에서 사용자의 요구가 충분히 반영되므로 유지보수의 작업이 적다.
<br>

## ■ 단점

- ### 반복적인 소프트웨어 개발 단계로 인해 필요한 투입 인력과 비용산정이 어렵다.
- ### 개발자 입장에서 프로토타이핑 과정을 관리, 통제하기 쉽지 않다.
- ### 프로토타입 개발에 있어서 추가 비용이 발생한다.
<br>

---

## 5. 나선형 모델

### - 프로토타입 모델에서 최종 프로토타입을 만들어 버리지 않고 이것을 계속 개발하여 최종 완성시키는 진화적 프로토타입 모델 절차를 따른다.

![image](https://user-images.githubusercontent.com/71022555/144896165-bf7ddca4-1935-4f6b-8507-07efe5cf3c61.png)

## 개발 절차

### 1. 계획 및 요구 분석 단계

- ### 사용자의 개발 의도를 파악하고 프로젝트의 목표를 명확히 하여 여러 제약 조건의 대안을 고려한 계획을 수립한다.
- ### 사용자의 요구를 통해 파악한 기능 요구 사항과 성능과 같은 비기능 요구사항을 정희하고 분석한다.
<br>

### 2. 위험 분석 단계

- ### 프로젝트 수행에 방해되는 위험 요소를 찾아 목록을 작성하고 위험에 대한 예방 대책을 논의한다.
- ### 고려요소 : 개발자의 이직, 요구 사항 변경, 발주사의 재정적 어려움, 예상과 달리 부족한 투입 인력, 개발 기간의 부족, 예상 개발비용 초과
<br>

### 3. 개발단계

- ### 프로토타입을 제작한다.(개발 프로세스 설계와 구현)
<br>

### 4. 사용자 평가 단계

- ### 가장 중요한 단계로 사용자가 프로토타입을 확인하고 요구사항을 반영하여 n차 프로토타입을 제작한다.
- ### 요구사항이 더 이상 없으면 최종 제출한다.

## □ 장점

- ### 위험을 고려하여 프로젝트를 진행하므로 갑작스럽게 발생한 위험으로 인한 프로젝트 중단의 확률이 낮다.
- ### 사용자의 요구사항을 충실히 반영하므로 사용자의 만족감이 높다.
<br>

## ■ 단점

- ### 요구 분석, 위험 분석, 개발, 사용자 평가가 반복적으로 계속 진행되기 때문에 프로젝트 기간이 길어질 수 있다.
- ### 반복 횟수가 많아질수록 프로젝트 관리가 어렵다.

<br>

---

## 6. ★ 애자일 프로세스 모델

### - 고객의 요구에 민첩하게 대응하고 그때그때 주어지는 문제를 풀어나가는 방법론을 말한다.

### - 프로세스와 도구 중심이 아닌 개개인과의 상호 소통을 중시한다.

### - 문서 중심이 아닌, 실행 가능한 소프트웨어를 중시한다.

### - 계약과 협상 중심이 아닌, 고객과의 협력을 중시한다.

### - 계획 중심이 아닌, 변화에 대한 민첩한 대응을 중시한다.(폭포수 모델은 계획, 문서)에 중점

<br>

## 애자일 개발 방법론

### ○ 스크럼

![image](https://user-images.githubusercontent.com/71022555/144966683-58b71143-c14d-4f06-8960-b8f3db1c9556.png)

### 1. 제품 기능 목록 작성

- ### 일반적인 개발 방법의 요구 사항에서 기능 목록과 같다고 보면 됩니다.
- ### 제품 책임자가 요구 사항 목록에 우선순위를 매겨 제품 기능 목록을 작성한다.
  ![image](https://user-images.githubusercontent.com/71022555/144966916-7d024e6a-ddce-4a5b-9ce5-0d5bf1315660.png)
  <br>

### 2. 사용자 스토리 작성

- ### ex) 메모지 한 장에 쓰인 사용자 요구사항
- ### 구현 할 기능이 사용자 관점에서 사용자 언어로 작성되어 있다.
- ### 고객의 요구 사항을 문서화한 것이 아니라 표현했다고 보는 것이 적합함.
- ### 유스케이스보다 작은 규모
- ### 테스트를 통해 스토리과 완료된 것을 확인한다.
<br>

### 3. 스토리 포인트 산정

- ### 사용자 스토리에 대한 업무에 대한 상대적인 개발 시간을 스토리 포인트라고 한다.
<br>

### 4. 스프린트

- ### 작은 단위의 개발 업무를 단기간 내에 전력 질주하여 개발한다는 뜻.
- ### 개발 팀이 애자일 방법에 대해 지식과 경험이 풍부하다면 2주 정도의 짧은 기간을 스프린트 주기로 한다.
- ### 요구 사항의 변화가 많고 개발 팀의 역량이 낮다면 4주 정도의 기간을 스프린트 주기로 한다.

### 5. 스프린트 구현 목록

- ### 스프린트 주기에서 개발할 작업 목록을 만한다.
- ### 작업 목록에는 세부적으로 어떤 것을 구현해야 하는지에 대한 세부 작업 항목과 작업자, 예상 작업 시간 등에 관한 정보를 작성한다.
<br>

### 6. 소멸 차트

- ### 시간이 이남에 따라 소멸되고 남은 것을 표현한다.
  ![image](https://user-images.githubusercontent.com/71022555/144973145-2a70b35c-0e91-4121-9ced-8496e91f7c48.png)
  <br>

### 7.스프린트 계획 회의

- ### 스프린트 계획은 각 스프린트에 대한 목표를 세우는 일과 제품 기능 목록에서 어떤 항목을 스프린트에서 진행할지 선택하는 것이다.
- ### 그리고 선택된 각 항목에 대해 개발자를 배정하고 세부적인 작업 단위로 계획을 수립하는 것이다.
<br>

### ◇ 전체적인 스프린트 계획 회의

- ### 스프린트 계획 회의 시작 단계에서 사용자의 대변인 격인 제품 책임자를 통해 사용자가 원하는 것이 무엇인지 파악하는데 중점
- ### 스크럼 마스터는 제품 기능 목록을 검토하면서 항목의 우선순위에 대한 의도를 그 배경과 목표에 대해 팀원들과 토의하며 제품 책임자의 의도를 파악한다.
<br>

### ◆ 세부적인 스프린트 계획 회의

- ### 우선순위가 높은 항목을 어떻게 구현할 것인지 구체적인 작업 계획을 세운다.
- ### 사용자 요구사항 목록인 제품 기능 목록에서 개발 항목을 결정하고 스프린트 구현 목록을 작성한다.
- ### 팀원들은 정해진 작업을 수행하는 데 소요되는 시간을 추정한다.
<br>

### 8. 일일 스크럼 회의

#### 스프린트 기간에 하는 회의로 다음과 같은 특징이 있다.

- ### 매일 한다.
- ### 서서 한다.
- ### 짧게 한다.
- ### 진행 상황만 점검한다.
- ### 개별 팀원에 대한 진척 상태를 확인한다.
- ### 그날의 남은 작업량을 소멸 차트에 표시한다.
<br>

### 9. 스프린트 현황판

#### 개발 팀의 개발 현황(진척도, 남은 작업, 진행 속도)을 나타낸다.

![image](https://user-images.githubusercontent.com/71022555/144973890-e4beabdd-044d-46ab-9b71-1f1532ff40f3.png)
<br>

### 10. 최종 제품

#### 모든 스프린트 주기가 끝나면 제품 기능 목록에서 개발하려고 했던 제품이 완성된다.

<br>

### 11. 스프린트 검토 회의

- ### 스프린트 반복 주기(2~4주)가 끝났을 때 생성되는 실행 가능한 제품에 대해 검토한다.
- ### 스프린트 목표를 달생했는지 작업 진행과 결과물을 확인하고 전체 흐름을 확인하여 비지니스 가치를 점검하는데 중점을 둔다.
- ### 스크럼 팀은 스프린트 동안 작업한 결과를 참석자(고객 포함)에게 시연하고 요구 사항에 얼마나 부합하는지 검토한다. 그리고 개선할 점 등에 관해 피드백을 받는다.
- ### 스크럼 마스터는 스프린트 동안 잘된 점, 미흡한 점, 개선할 사항 등을 찾기 위한 회고를 진행할 수 있다.
<br>

### 12. 스프린트 회고

- ### 지나간 일을 돌이켜 생객해 보는 것이다.
- ### 팀의 단점보다는 강점을 찾아 더 극대회하는 데 주안점을 둔다.
- ### 해결 방안을 찾는 회의가 아니므로 문제점을 확인하고 기록하는 정도로만 진행한다.
- ### 완성품의 작동 추정 속도와 실제 속도를 비교해보고 차이가 크면 그 이유를 분석한다.
<br>

### 13. 배포 목록

- ### 사용자에게 시스템 일부를 제공하는 것이다.
- ### 제품 기능 목록의 항목 중에서 이번 배포 본에 포함하기로 결정한 항목을 배포한다.

### 제품 책임자, 스크럼 마스터, 스크럼 팀

![image](https://user-images.githubusercontent.com/71022555/144974545-802bf18b-a5bc-41ff-8938-15503c0bff92.png)

### □ 장점

- ### 반복 주기마다 생산되는 실행 가능한 제품을 통해 사용자와 충분히 의견을 나눌 수 있다.
- ### 일일 회의를 함으로써 팀원들 간에 신속한 협조와 조율이 가능하다.
- ### 일일 회의 시 직접 자신의 일정을 발표함으로써 업무에 집중할 수 있는 환경이 조성된다.
- ### 다른 개발 방법론들에 비해 단순하고 실천 지향적이다.
- ### 스크럼 마스터는 개발 팀원들이 목표 달성에 집중할 수 있도록 팀의 문제를 해결한다.
- ### 프로젝트의 진행 현황을 볼 수 있어, 신속하게 목표와 결과 추정이 가능하다.
- ### 프로젝트의 진행 현황을 볼 수 있어 목표에 맞게 변화를 시도할 수 있다.
<br>

### ■ 단점

- ### 추가 작업 시간 필요 : 반복 주기마다 테스트할 수 있는 제품을 만들어야 하므로
- ### 투입 공수 불측정에 따른 효율성 평가 불가 : 투입 공수를 측정하지 않기 때문에 얼마나 효율적으로 수행되었는지 알기 어렵다.
- ### 프로세스 품질 평가 불가 : 스크럽은 프로젝트 관리에 무게 중심을 많이 둔 방법이다. 프로세스 품질을 평가하지 않기 때문에 품질 관련 활동이 미약하고 따라서 품질의 정도를 알 수 없다.
