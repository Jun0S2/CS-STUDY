# TCP

## TCP (Transmission Control Protocol)

### 정의

1. **서버와 클라이언트간에 데이터를 신뢰성 있게 전달**하기 위해 만들어진 프로토콜
2. 데이터를 전송하기 전에 **데이터 전송을 위한 연결(포트)을 만드는 프로토콜**이다
3. 데이터는 네트워크 선로를 통해 전달되는 과정에서 손실이나 순서가 뒤바뀌어서 전달될 수 있는데, TCP는 손실을 검색해 내서 이를 교정하고 순서를 재조합할수 있게 해준다
4. OSI 계층 모델의 관점에서 전송계층 (4층)에 해당

### 특징

1. 신뢰성(realiable)
- 패킷 손실, 중복, 순서바뀜 등이 없도록 보장(적극적 수신, 통지, 재전송 체계 사용)
- TCP 하위계층인 IP계층의 신뢰성 없는 서비스에 대해 다방면으로 신뢰성 제공
- UDP에 비해 신뢰성 높음
1. 흐름제어(Flow Control)와 혼잡제어(Conegestion Flow)
    
    신뢰성있는 네트워크를 보장하기 위해선, 아래 4가지 문제점을 해결해야 하는데 이를 위해 흐름제어/혼잡제어가 필요하다.
    
    [Reliable Network - 4가지 문제점](TCP%202b7bb/Reliable%20N%20147ac.csv)
    
    A. 흐름제어
    
    TCP 데이터 세그먼트를 송수신하는 컴퓨터는 CPU와 네트워크 대역폭 차이 때문에 서로 다른 데이터 속도로 작동할 수 있다. 결국 수신자가 처리할 수 있는것처럼 훨씬 더 빠른속도로 송신자가 데이터를 보낼 가능성이 많다.
    
    - 송신측과 수신측의 **데이터 처리 속도 차이를 해결**하기 위한 기법
    - Receiver 가 packet을 지나치게 받지 않도록 조절
    - Receiver 가 sender에게 현재 자신의 상태를 feedback
    - Overload 해결
    
    B. 혼잡제어
    
    - 송신측의 **데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결**하기 위한 기법
    - Congestion을 해결하기 위한 전략
    
2. 다중화 (Multiplexing)

[https://sectionr0.tistory.com/40](https://sectionr0.tistory.com/40) 참고

TCP에서는 한 라우터의 많은 프로세스가 TCP 통신 서비스를 동시에 사용할 수 있다. 이를 TCP 다중화라고 한다. 

![Untitled](TCP%202b7bb/Untitled.png)

이들 프로세스는 같은 네트워크 인터페이스에서 통신할 수 있으므로 네트워크 인터페이스의 IP 주소로 식별된다. 하지만, 한 컴퓨터의 동일 네트워크 인터페이스를 사용하는 모든 프로세스가 공동의 IP 주소를 사용하기 때문에, TCP는 **TCP를 사용하는 응용프로그램에 포트 번호값을 연계**시킨다. 

각 연결은 서로 다른 포트 쌍을 사용하여 프로그램 프로세스들 사이에 여러 연결이 존재할 수 있게 해준다. 응용 프로그램 프로세스에 대한 포트의 바인딩은 각 컴퓨터에서 독립적으로 처리된다.

1. 연결 지향적(Connected- Oriented)
- 같은 전송계층의 UDP가 비연결성(connectionless)인것과 달리, TCP는 연결 지향적이다
- 느슨한 연결(Loosly Connected)
- 연결 관리를 위한 연결 설정 및 연결 해제 필요

## 3 way handshake & 4 way handshake

TCP는 위와 같은 특성을 지니며, 이를 구현하기 위해 다음과같은 기법을 사용한다.

### 3 way handshake

**TCP의 연결을 초기화 할 때 사용**

양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장 → 실제로 데이터 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 한다.

![Untitled](TCP%202b7bb/Untitled%201.png)

**[STEP 1]**

A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태  가 되는 것이다.

**[STEP 2]**

이때 서버는 Listen 상태로 포트 서비스가 가능한 상태여야 한다. (Closed :닫힌상태) B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.

**[STEP 3]**

A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.

위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.

### 4 way handshake

**4-Way handshake는 세션을 종료하기 위해 수행되는 절차**

![Untitled](TCP%202b7bb/Untitled%202.png)

**[STEP 1]**

클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다. 이때 **A클라이언트는  FIN-WAIT** 상태가 된다.

**[STEP 2]**

B서버는 FIN플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가

**B서버의 CLOSE_WAIT**상태다.

**[STEP 3]**

연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해  클라이언트에게 FIN플래그를 전송한다. 이때 B서버의 상태는 **LAST-ACK**이다.

그런데 무슨 준비를 하길래?

- 미리 왔던 요청에 대해 보내야 할 응답을 보냄(클라이언트의 Time-wait은 이걸 기다리는 상태)
- 소켓 정리

**[STEP 4]**

클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.

**A클라이언트의 상태가 FIN-WAIT ->TIME-WAIT** 으로 변경된다.