# 정렬_권영현

![Untitled](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF_%E1%84%80%E1%85%AF%E1%86%AB%205dc63/Untitled.png)

# 선택정렬

### 방법

### 1.선택정렬 주어진 리스트에서 최솟값을 찾는다.

### 2.최솟값을 맨 앞 자리의 값과 교환한다.

### 3.그 다음자리부터 마지막까지 반복

![Untitled](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF_%E1%84%80%E1%85%AF%E1%86%AB%205dc63/Untitled%201.png)

## 소스

![Untitled](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF_%E1%84%80%E1%85%AF%E1%86%AB%205dc63/Untitled%202.png)

## 장점

1. 추가적인 메모리 소비가 작다.

## **단점**

1. 시간복잡도가 O(N^2)이다.  
2. 안정적인 정렬이 아니다.

                                                   **시간복잡도 설명**

![Untitled](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF_%E1%84%80%E1%85%AF%E1%86%AB%205dc63/Untitled%203.png)

**안정 정렬 불안전 정렬 링크 :** 

[[알고리즘] - 안정 정렬(Stable Sort)과 불안정 정렬(Unstable Sort) #2](https://godgod732.tistory.com/10)

**이유 :**

[[알고리즘] - 선택 정렬(Selection sort) #5](https://godgod732.tistory.com/13?category=659135)

# 퀵 정렬

퀵 정렬(Quick Sort)은 정렬할 전체 값들을 정렬을 수행하지 않고 기준값을 중심으로 왼쪽 부분집합과 오른쪽 부분집합으로 분할한다.

 왼쪽 부분 집합에는 기준값보다 작은 원소들을, 오른쪽 부분집합에는 기준값보다 큰 원소들을 이동.

 이 때 사용하는 **기준값 = Pivot(피봇)** 이라고 칭한다.

## 전체적인 개념

1. 피벗을 하나 선택한다.
2. 피벗을 기준으로 양쪽에서 피벗보다 큰 값, 혹은 작은 값을 찾는다. 왼쪽에서부터는 피벗보다 큰 값을 찾고, 오른쪽에서부터는 피벗보다 작은 값을 찾는다.
3. 양 방향에서 찾은 두 원소를 교환한다.
4. 왼쪽에서 탐색하는 위치와 오른쪽에서 탐색하는 위치가 엇갈리지 않을 때 까지 2번으로 돌아가 위 과정을 반복한다.
5. 엇갈린 기점을 기준으로 두 개의 부분리스트로 나누어 1번으로 돌아가 해당 부분리스트의 길이가 1이 아닐 때 까지 1번 과정을 반복한다. (Divide : 분할)
6. 인접한 부분리스트끼리 합친다. (Conquer : 정복)

## 특징

- 파이썬의 `list.sort()` 함수나 자바의 `Arrays.sort()`처럼 프로그래밍 언어 차원에서 기본적으로 지원되는 내장 정렬 함수는 대부분은 퀵 정렬을 기본으로 합니다.
- 일반적으로 원소의 개수가 적어질수록 나쁜 중간값이 선택될 확률이 높아지기 때문에, 원소의 개수에 따라 퀵 정렬에 다른 정렬을 혼합해서 쓰는 경우가 많습니다.
- 병합 정렬과 퀵 정렬은 분할 정복과 재귀 알고리즘을 사용한다는 측면에서는 유사해보이지만, 내부적으로 정렬을 하는 방식에서는 큰 차이가 있습니다.
- 병합 정렬은 항상 정 중앙을 기준으로 단순 분할 후 병합 시점에서 값의 비교 연산이 발생하는 반면, 퀵 정렬은 분할 시점부터 비교 연산이 일어나기 때문에 그 이후 병합에 들어가는 비용이 매우 적거나 구현 방법에 따라서 아예 병합을 하지 않을 수도 있습니다.

## 복잡도

- 쿽 정렬의 성능은 어떻게 pivot 값을 선택 선택하느냐에 크게 달라질 수 있습니다. 이상적인 경우에는 pivot 값을 기준으로 동일한 개수(반, 반으로 나뉘어 질 때)의 작은 값들과 큰 값들이 분할되어 병합 정렬과 마찬가지로 `O(NlogN)`의 시간 복잡도를 가지게 됩니다.
- 하지만 pivot 값을 기준으로 분할했을 때 값들이 한 편으로 크게 치우치게 되면, 퀵 정렬은 성능은 저하되게 되며, 최악의 경우 한 편으로만 모든 값이 몰리게 되어 `O(N^2)`의 시간 복잡도를 보이게 됩니다.
- 따라서 상용 코드에서는 중앙값(median)에 가까운 pivot 값을 선택할 수 있는 섬세한 전략이 요구되며, 배열의 첫값과 중앙값 그리고 마지막값 중에 크기가 중간인 값을 사용하는 방법이 많이 사용됩니다.
- 퀵 정렬은 공간 복잡도는 구현 방법에 따라 달라질 수 있는데, 입력 배열이 차지하는 메모리만을 사용하는 in-place sorting 방식으로 구현을 사용할 경우, `O(1)`의 공간 복잡도를 가진 코드의 구현이 가능합니다.

![Untitled](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF_%E1%84%80%E1%85%AF%E1%86%AB%205dc63/Untitled%204.png)

## 장점

- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.

## 단점

- **불안정 정렬(Unstable Sort)** 이다.
- 정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

![Untitled](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF_%E1%84%80%E1%85%AF%E1%86%AB%205dc63/Untitled%205.png)