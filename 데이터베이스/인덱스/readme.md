# 인덱스

<br>

### 인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조입니다. (책의 목차같은 개념)

<br>

### 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장됩니다.

<br>

### 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.

<br>

### 만약 인덱스를 타게 되면 아래의 그림과 같이 인덱스를 타게 되고 먼저 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작을 하여 SELECT, UPDATE, DELETE 속도의 향상을 가져올 수 있습니다.

<br>

### 인덱스(Index)를 사용하면 Order by에 의한 Sort과정을 피할수가 있습니다. Order by는 굉장히 부하가 많이 걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다. 이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요.

<br>

### MIN값과 MAX값을 레코드의 시작값과 끝 값 한건씩만 가져오면 되기에 FULL TABE SCAN으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있습니다.

<br>

![image](https://user-images.githubusercontent.com/71022555/136755233-b7905b72-4341-4005-9da7-9e1c47432ff0.png)
<br>

### 만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

## <br>

<br>

## 인덱스(INDEX)의 관리

### DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.

<br>

- ### INSERT: 새로운 데이터에 대한 인덱스를 추가함
- ### DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- ### UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함
<br>

---

<br>

## 인덱스(INDEX)의 장점과 단점

<br>

- ### 장점

      - 테이블을 조회하는 속도와 그에 따른 성능을 향상
      - 전반적인 시스템의 부하를 줄일 수 있다.

  <br>

- ### 단점
  - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
  - 인덱스를 관리하기 위해 추가 작업이 필요하다.
  - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

<br>

### ex) 만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다.

### 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다. 그렇기 때문에 사용하지 않는 인덱스는 바로 제거를 해주어야 한다.

<br>

---

<br>

## 인덱스(INDEX)를 사용하면 좋은 경우

1. ### 규모가 작지 않은 테이블
2. ### INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
3. ### JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 걸럼
4. ### 데이터의 중복도가 낮은 컬럼
<br>

인덱스 만드는 방법 https://coding-factory.tistory.com/419
<br>

---

<br>

## 인덱스 자료구조

## 해시 테이블

<br>

### 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다.

<br>

### 하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

<br>

### 즉, 예를 들면 "나는"으로 시작하는 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜택을 전혀 받지 못하게 된다. 이러한 이유로 데이터베이스의 인덱스에서는 B+Tree가 일반적으로 사용된다.

![image](https://user-images.githubusercontent.com/71022555/136761110-1885a17a-3fd0-42e6-a272-c1e7779ce8f4.png)

## B Tree 인덱스

### 밸런스드 트리 인덱스 구조입니다. 그리고 B TREE 인덱스 중에서도 가장 많이 사용하는것은 B\*TREE 와 B+TREE 구조를 가장 많이 사용되는 인덱스의 구조입니다.

<br>

![image](https://user-images.githubusercontent.com/71022555/136760154-682bb6a3-af54-4336-b8c9-c6dc53cfff6d.png)

## B-Tree

![image](https://user-images.githubusercontent.com/71022555/136760080-f3c139f9-5b97-424a-b2fa-0ac47e8587fd.png)

## 특징

- ### Binary search tree와 유사하지만, 한 노드 당 자식 노드가 2개 이상 가능하다.
- ### B-tree의 장점 한 가지는 '어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다'인데, 이를 '균일성'이라고 한다.
- ### 균형 트리
  ![image](https://user-images.githubusercontent.com/71022555/136760349-c67fcc33-46c3-4284-8da8-041e6152f9c4.png)
- ### 그러나, B-tree 처음 생성 당시는 균형 트리이지만 테이블 갱신(INSERT/UPDATE/DELETE)의 반복을 통해 서서히 균형이 깨지고, 성능도 악화된다.
- ### 어느 정도 자동으로 균형을 회복하는 기능이 있지만, 갱신 빈도가 높은 테이블에 작성되는 인덱스 같은 경우 인덱스 재구성을 해서 트리의 균형을 되찾는 작업이 필요하다.
<br>

---

<br>

## B+Tree

### B+tree는 B-tree의 확장개념으로, B-tree의 경우, internal 또는 branch 노드에 key와 data를 담을 수 있다. 하지만, B+tree의 경우 브랜치 노드에 key만 담아두고, data는 담지 않는다. 오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결되어 있다.

<br>

### 장점

<br>

1. ### 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.(cache hit를 높일 수 있음)
2. ### 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다.
   InnoDB에서 사용된 B+tree
   ![image](https://user-images.githubusercontent.com/71022555/136760834-900144ec-0aca-42a2-87a5-66690bb063bb.png)

같은 레벨의 노드들끼리는 Linked List가 아닌 Double Linked List를 사용했고, 자식 노드로는 Single Linked List로 연결되어있다.
<br>

---

<br>

## B-Tree VS B+tree

![image](https://user-images.githubusercontent.com/71022555/136761284-4db94caf-1171-4c40-be8f-66d41ac7e254.png)
